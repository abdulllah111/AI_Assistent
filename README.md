# Кароче

Есть две очереди RabbitMQ (request_queue, response_queue).

Есть Telegram бот на .Net7.0

Есть gRPC сервер на .Net7.0, являющийся продюсером request_queue и консьюмером response_queue. У ссервера следующий контракт:
```dart
message PromtRequest {
  string message = 1;
  string userid = 2;
}

message PromtResponse {
  string response = 1;
  string userid = 2;
}
```

Есть puthon клиент, который является консьюмером request_queue и продюсером response_queue.

## Как работает

- Telegram бот при получении сообщения отправляет message и userid серверу
- Сервер получает сообщение, засовывает его в очередть request_queue
- Python клиент принимает это сообщение из очереди request_queue
- Дальше python клиент отправляет это сообщение на выбранный API нейронки
- Получает ответ, и засовывает этот ответ в response_queue
- Сервер принимает это сообзщение из очереди response_queue
- Сервер возвращает response Telegram боту

## Дополнительно
- Каждый юзер, от которого пришло сообщение - имеет свою историю чата с нейронкой. Это реализовано с помощью записи массива промптов и ответов в словарь и сохранение словаря в json файл.
- Есть выбор бесплатных api нейронок. Некоторые работают, некоторые когда как. Надо тестить каждую
- Решил реализовать архитектуру именно так, потому что сервер и python клиент не должны быть подвергнуты изменениям при изменении бота. Допустим, вместо телеграм бота может быть вк бот. Главное, чтоб контракт был одинаковый.
- Список библиотек для python клиента в `src/AIService_Python_Client/requirements.txt`
- Стартовый промпт писал под себя, изменить можно тут `src/AIService_Python_Client/gpt.py`
- Любые токены и ключи, найденные в исходниках - нерабочие, так что можете не проверять.
